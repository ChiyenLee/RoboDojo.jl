# Chiyen's note on running the code.. 


# 1. Code are defined in the src/robots/{robot_name}/model.jl 
#    1. Each model.jl needs to include:
#        mass_matrix, dynamics_bias (or just lagrangian..?)
#        contact_kinematics, contact_kinematics_jacobians
# 2. Dynamics are generated in src/robots/codegen.jl 
#        codegen_dynamics(model) use the lagrangian to find mass_matrix and 
#        coriolis_matrix function 
#        it also use the dynamics, contact_kinematics, contact_kinematics 
#        to find residual (generated by codegen_residual)
# 3. codegen_residual() is defined in src/simulator/codegen.jl 
#        jacobians with respect to z and θ are found analytically in there
# 4. codegen_residual() calls residual() which is defined in src/simulator/residual.jl 
#        residual calls dynamics which is defined in src/robots/integrator.jl 
#        this dynamics is a variational integrator 
# 5. Stored jld2 files are stored inside scratch spaces... see https://github.com/JuliaPackaging/Scratch.jl
# 6. In this repo, the θ denotes data (which are parameters of some sort that doesn't change during optimization),
#                      z denotes variables (things that we are solving for)

# GOAL: make system inertial parameter part of the input and get the gradient 
# 1. Change the model.jl's mass_matrix, dynamics_bias, and lagrangian function 
#    such that it includes system parameter as a function 

# ## Setup
using Revise
using RoboDojo

# ## Initial conditions
# q1 = nominal_configuration(centroidal_quadruped_param) 
model_path = joinpath(dirname(pathof(RoboDojo)), "robots/centroidal_quadruped_param", "model.jl")
sim_path = joinpath(dirname(pathof(RoboDojo)), "robots/centroidal_quadruped_param", "simulator.jl")

include(model_path)
include(sim_path)

r_model, rz_model, rθ_model = codegen_residual(centroidal_quadruped_param, 
                                               codegen_dynamics(centroidal_quadruped_param)..., 
                                               centroidal_quadruped_param_contact_kinematics, 
                                               centroidal_quadruped_param_contact_kinematics_jacobians)
# residual_expr(centroidal_quadruped_param)
RESIDUAL_EXPR[String(name(centroidal_quadruped_param)) * "_r"] = eval(r_model)
RESIDUAL_EXPR[String(name(centroidal_quadruped_param)) * "_rz"] = eval(rz_model)
RESIDUAL_EXPR[String(name(centroidal_quadruped_param)) * "_rθ"] = eval(rθ_model)

residual_expr(centroidal_quadruped_param)
jacobian_var_expr(centroidal_quadruped_param)
jacobian_data_expr(centroidal_quadruped_param)
sim = Simulator(centroidal_quadruped_param, 100; diff_sol=true)

q1 = nominal_configuration(centroidal_quadruped) 
v1 = zeros(centroidal_quadruped.nq)
reset!(sim.traj)
reset!(sim.grad)
set_state!(sim, q1, v1, 1)
set_param!(sim, [centroidal_quadruped.mass_body,
                 centroidal_quadruped.inertia_body[1,1], 
                 centroidal_quadruped.inertia_body[2,2],
                 centroidal_quadruped.inertia_body[3,3]], 1)
step!(sim, q1, v1, ones(12), 1)


## Setting up control (IterativeLQR)


# s = LciMPC.get_simulation("centroidal_quadruped", "flat_3D_lc", "flat")


## EKF Example
